---
cdate: 2022-12-19
mdate: 2022-12-19
authorId: kwozniak
stack: javascript
tags: language,syntax,apis
description: Learn the difference between Proxy and Reflect and their useful use cases.
readTime: 5
title: Proxy and reflect in JavaScript
---

<Prelude>
  <M>
    Have you ever wondered how to interact with code written by other
    programmers without intruding on their code?
  </M>
  <M>
    There is something called <B>metaprogramming</B>. Thanks to it you will
    achieve what I mentioned above.
  </M>
  <M>
    Two objects will help you: <B>Proxy</B> and <B>Reflect</B>. Today you will
    learn how, when and where you can use them to master a powerful technique.
  </M>
  <Hint hasBg>
    Metaprogramming is not invented by <B>Meta</B> company ü§°.
  </Hint>
</Prelude>

<Section>
  <XL>1. Metaprogramming</XL>
  <M>
    To start talking about <B>metaprogramming</B>, you need to answer the
    question: what is <B>data</B> and <B>code</B>? Every programming language
    has both of these but what it exactly mean?
  </M>
  <M>
    <B>Data</B> can be for example:
  </M>
  <List items="number, symbol, array, object, string" />
  <M>
    <B>Code</B> is an expression - an instruction to be executed on this{" "}
    <B>data</B>. It can be:{" "}
    <B hasBg fullBg>
      const result = 1 + (2 * 3)
    </B>
    .
  </M>
  <M>
    At first glance, you can say that it is a mathematical expression, and this
    is indeed the case if we are talking about the field of mathematics.
    However, according to the presented approach, we will consider it in two
    ways:
  </M>
  <List items="by data: '1 + (2 * 3)' - is a string!, by code: '1 + (2 * 3)' - is it code snippet? Then it is 7!" />
  <M>
    From this it follows that the same representation of an expression can have
    different interpretations. This approach is what <B>metaprogramming</B> is
    all about.
  </M>
  <M>
    Knowing this is a powerful tool for building data and expressions. It allows
    us to create functions that multiply data which means we can write programs
    that write programs. It is a certain level of abstraction.
  </M>
  <M>To illustrate this more easily, let's discuss it with this example:</M>
  <Code
    description="For loop"
    src="/snippets/proxy-and-reflect-in-javascript/for.js"
  />
  <M>
    According to the data, it is plain text, but according to the code, it is
    something to be interpreted as an instruction, so:
  </M>
  <Code
    description="For as set of instructions"
    src="/snippets/proxy-and-reflect-in-javascript/for-pseudo.txt"
  />
  <Hint hasBg>
    Congratulations, you have just successfully interpreted a piece of code
    through metaprogramming! You're probably wondering what this has to do with
    the topic of the article? "Stay awhile and listen".
  </Hint>
</Section>

<Section>
  <XL>2. What is an Proxy pattern</XL>
  <M>
    A proxy is a structural design pattern that allows you to create a proxy
    object in place of another object. A proxy is a kind of guardian that
    protects access to the original object, or changes its behavior during a
    specific action.
  </M>
  <M>
    How do you translate this into a simple example from life? Cash! Hmm? Cash
    is the physical representation of the capital placed in your bank account.
    But what about it? Have you ever used a credit card? Well, think about it, a
    card is actually a proxy for your cash in the bank. You don't need to
    physically have paper money with you to buy something. Both of these
    entities implement the same interface (you can perform an action with them:
    pay). At the same time, you are actually operating an object that protects
    another object (in the bank).
  </M>
</Section>

<Section>
  <XL>3. Proxy in JavaScript</XL>
  <M>Let's start with a simple example for reference:</M>
  <Code
    description="Your first Proxy"
    src="/snippets/proxy-and-reflect-in-javascript/what-it-comes-with.js"
  />
  <M>This syntax has several important aspects to describe the proxy:</M>
  <List items="target - (ProtectedObject) is a object to protect by guard, trap - proxy config that has methods that intercept operations, handler - object of traps definitions" />
  <M>
    Some of the methods have certain implementation conditions. SET must return
    true if the value was assigned correctly and false otherwise, DELETE must
    return true if the value was deleted correctly and false otherwise etc.
  </M>
  <M>
    When does a proxy make sense? The proxy should totally replace the target
    object everywhere. No one should ever reference the target object after it
    got proxied. Otherwise it‚Äôs easy to mess up.
  </M>
</Section>

<Section>
  <XL>4. Proxy use cases</XL>
  <M>Logging access to an object:</M>
  <Code
    description="Logging properties"
    src="/snippets/proxy-and-reflect-in-javascript/logging-access-to-obj.js"
  />
  <M>Custom error handling/validation:</M>
  <Code
    description="Cool validation"
    src="/snippets/proxy-and-reflect-in-javascript/validation.js"
  />
  <M>Protect the object field:</M>
  <Code
    description="Like a guard"
    src="/snippets/proxy-and-reflect-in-javascript/guard.js"
  />
  <M>Lazy Initialization:</M>
  <Code
    description="Lazy af"
    src="/snippets/proxy-and-reflect-in-javascript/lazy.js"
  />
</Section>

<Section>
  <XL>5. Reflect feature in JavaScript</XL>
  <M>
    Reflect is a Javascript native object that provides methods same as proxy
    feature. It is not a functional object, so its methods are static (not
    constructable). What does this mean? We can't create an instance of a
    Reflect object through the 'new' operator or call it like a function.
  </M>
  <M>
    So which approach should I use? Which is better? In my opinion: <B>both</B>.
  </M>
  <M>
    Proxy provides us with a number of options for changing an object's behavior
    during particular actions, while Reflect gives us access to their default
    behavior.
  </M>
  <M>It is a modified example 'Protect the object field':</M>
  <Code
    description="Guard but with Reflect"
    src="/snippets/proxy-and-reflect-in-javascript/reflect-guard.js"
  />
  <M>Simpler? Clearer? Without an additional condition? Of course it is.</M>
  <M>
    Besides, the Reflect object provides us with a lot of functionality, which
    can be categorized as 'sugar syntax'.
  </M>
</Section>

<Section>
  <XL>6. Reflect use cases</XL>
  <M>Need to find out if an object has a field?</M>
  <Code
    description="Searching..."
    src="/snippets/proxy-and-reflect-in-javascript/find-field.js"
  />
  <M>Need to return all the keys of an object?</M>
  <Code
    description="Keys list"
    src="/snippets/proxy-and-reflect-in-javascript/keys-in-obj.js"
  />
  <M>Want to add a new field? No problem!</M>
  <Code
    description="Adding field"
    src="/snippets/proxy-and-reflect-in-javascript/new-field.js"
  />
</Section>

<Summary>
  <M>
    I hope you understand now Proxy and Reflect üßë‚Äçüíª. I must say they are tricky but
    useful and powerful.
  </M>
  <M>
    Next time when you see an ugly, old legacy code. Remember, that you have
    these API's and there is maybe good use case for them.
  </M>
  <M>
    Feel free to contact me if you have any questions/proposals. Have a nice day
    and good health!
  </M>
</Summary>
